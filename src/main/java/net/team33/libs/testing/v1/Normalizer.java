package net.team33.libs.testing.v1;

import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.BiFunction;
import java.util.stream.Collectors;

import static java.util.stream.Collectors.toMap;

/**
 * <p>A tool that is used to bring virtually any object into a 'normalized' form so that they can be compared with one
 * another and have a meaningful string representation, even if they themselves do not have a suitable implementation
 * of {@link Object#equals(Object) equals()} / {@link Object#hashCode() hashCode()} or {@link Object#toString()
 * toString()}.</p>
 *
 * <p>This can e.g. be useful in test cases when results are to be checked for expected values.</p>
 *
 * <p>A normalizer instance is widely configurable. It is generated by a builder to which various properties can be
 * assigned beforehand.</p>
 *
 * @see #builder()
 * @see #DEFAULT
 */
public final class Normalizer {

    /**
     * <p>A predefined instance with the following behavior for {@link #normal(Object)}:</p>
     * <ul>
     *     <li>Any {@link Set} will be converted to a {@link Set} of {@link #normal(Object) normalized} elements.</li>
     *     <li>Any other {@link Collection} will be converted to a {@link List} of {@link #normal(Object) normalized}
     *     elements.</li>
     *     <li>Any {@code array} will also be converted to a {@link List} of {@link #normal(Object) normalized}
     *     elements.</li>
     *     <li>Any {@link Map} will be converted to a {@link Map} of {@link #normal(Object) normalized} keys and
     *     values.</li>
     *     <li>Any other object that has a specific {@link Object#equals(Object) equals()},
     *     {@link Object#hashCode() hashCode()} and {@link Object#toString() toString()} implementation remains
     *     unchanged.</li>
     *     <li>Any other object is converted to a {@link Map}, using the names of their fields as keys and the
     *     {@link #normal(Object) normalized} field values as values.</li>
     * </ul>
     */
    public static final Normalizer DEFAULT = builder().build();

    public static final Comparator<Object> ORDER = new Order();
    private static final String NO_ACCESS = "cannot access field <%s> for subject <%s>";
    private static final Map<Class<?>, Map<String, Field>> FIELDS_CACHE = new ConcurrentHashMap<>(0);

    @SuppressWarnings("rawtypes")
    private final Map<Class, BiFunction> methods;
    private final Methodology methodic;

    private Normalizer(final Builder builder) {
        methods = new ConcurrentHashMap<>(0);
        methodic = new Methodology(builder.methods);
    }

    public static Builder builder() {
        return new Builder();
    }

    private static Map<String, Field> newFieldMap(final Class<?> subjectClass) {
        return Fields.deepStreamOf(subjectClass)
                     .filter(Fields.IS_SIGNIFICANT)
                     .peek(field -> field.setAccessible(true))
                     .collect(toMap(field -> Fields.compactName(subjectClass, field), field -> field));
    }

    public final Object normal(final Object subject) {
        final Class<?> subjectClass = (null == subject) ? void.class : subject.getClass();
        return getMethod(subjectClass).apply(this, subject);
    }

    @SuppressWarnings("unchecked")
    private BiFunction<Normalizer, Object, Object> getMethod(final Class<?> subjectClass) {
        return methods.computeIfAbsent(subjectClass, methodic::getMethod);
    }

    public final Map<?, ?> normalFieldMap(final Object subject) {
        return normalFieldMap(subject.getClass(), subject);
    }

    public final Map<?, ?> normalFieldMap(final Class<?> subjectClass, final Object subject) {
        return FIELDS_CACHE.computeIfAbsent(subjectClass, Normalizer::newFieldMap)
                           .entrySet().stream()
                           .collect(TreeMap::new,
                                    (map, entry) -> put(map, entry, subject),
                                    Map::putAll);
    }

    private void put(final Map<Object, Object> map,
                     final Map.Entry<String, Field> entry,
                     final Object subject) {
        try {
            map.put(normal(entry.getKey()), normal(entry.getValue().get(subject)));
        } catch (final IllegalAccessException caught) {
            throw new IllegalStateException(String.format(NO_ACCESS, entry.getValue(), subject), caught);
        }
    }

    public final List<Object> normalArray(final Object array) {
        final int length = Array.getLength(array);
        final List<Object> result = new ArrayList<>(length);
        for (int i = 0; i < length; ++i) {
            result.add(normal(Array.get(array, i)));
        }
        return result;
    }

    public final List<Object> normalList(final Collection<?> subject) {
        return subject.stream()
                      .map(this::normal)
                      .collect(Collectors.toList());
    }

    public final Set<?> normalSet(final Set<?> subject) {
        return subject.stream()
                      .map(this::normal)
                      .collect(Collectors.toCollection(() -> new TreeSet<>(ORDER)));
    }

    public final Map<?, ?> normalMap(final Map<?, ?> subject) {
        return subject.entrySet().stream()
                      .collect(
                              () -> new TreeMap<>(ORDER),
                              (map, entry) -> map.put(normal(entry.getKey()),
                                                      normal(entry.getValue())),
                              Map::putAll);
    }

    @SuppressWarnings({"rawtypes", "unchecked"})
    private static final class Methodology {

        private final Map<Class, BiFunction> methods;

        private Methodology(final Map<Class, BiFunction> methods) {
            this.methods = Collections.unmodifiableMap(new HashMap<>(methods));
        }

        private static BiFunction<Normalizer, Object, Object> getDefault(final Class keyClass) {
            if (void.class.equals(keyClass))
                return (ignored, subject) -> subject;
            if (keyClass.isArray())
                return Normalizer::normalArray;
            if (Classes.isValueClass(keyClass))
                return (ignored, subject) -> subject;
            throw new IllegalArgumentException("no method specified for " + keyClass);
        }

        private static Optional<Class> bestMatch(final Set<Class> classSet, final Class keyClass) {
            return classSet.stream()
                           .filter(element -> element.isAssignableFrom(keyClass))
                           .reduce((left, right) -> {
                               if (Distance.of(right).from(keyClass) < Distance.of(left).from(keyClass)) {
                                   return right;
                               } else {
                                   return left;
                               }
                           });
        }

        private BiFunction getMethod(final Class keyClass) {
            final Optional<Class> match = bestMatch(methods.keySet(), keyClass);
            return match.map(methods::get)
                        .orElseGet(() -> getDefault(keyClass));
        }
    }

    /**
     * A builder for new instances of {@link Normalizer}.
     */
    public static final class Builder {

        @SuppressWarnings("rawtypes")
        private final Map<Class, BiFunction> methods = new HashMap<>(0);

        private Builder() {
        }

        /**
         * <p>Adds a method that will be used by a {@link #build() resulting} {@link Normalizer} to
         * {@link #normal(Object) normalize} instances of a particular class or one of its derivatives.
         * The method will get two parameters:</p>
         * <ol>
         *     <li>The executing {@link Normalizer} itself</li>
         *     <li>The instance to be normalized, so called: {@code subject}</li>
         * </ol>
         *
         * <p>If different methods defined in this way compete in a specific application, because a {@code subject} can
         * be assigned to several classes, the method is used whose associated class in the hierarchy is closer to the
         * original class of the {@code subject}.</p>
         *
         * <p>If different methods continue to compete because the {@code subject} can be assigned to several classes
         * that are equally close in the hierarchy to the original class of the {@code subject}, the method that was
         * added here last is used.</p>
         */
        public final <T> Builder addMethod(final Class<T> subjectClass,
                                           final BiFunction<Normalizer, T, Object> method) {
            methods.put(subjectClass, method);
            return this;
        }

        public final Normalizer build() {
            return new Normalizer(this);
        }
    }

    private static class Order implements Comparator<Object> {

        @Override
        public final int compare(final Object left, final Object right) {
            if (null == left) {
                return (null == right) ? 0 : -1;
            } else if (null == right) {
                return 1;
            } else if (left.equals(right)) {
                return 0;
            }

            final int result = compareString(left.toString(), right.toString());
            if (0 == result) {
                return Integer.compare(System.identityHashCode(left), System.identityHashCode(right));
            } else {
                return result;
            }
        }

        private static int compareString(final String left, final String right) {
            final int result = left.compareToIgnoreCase(right);
            if (0 != result) {
                return result;
            } else {
                return compareStringCaseSensitive(left, right);
            }
        }

        private static int compareStringCaseSensitive(final String left, final String right) {
            final int result2 = left.compareTo(right);
            if (0 != result2) {
                return result2;
            } else {
                return Integer.compare(System.identityHashCode(left), System.identityHashCode(right));
            }
        }
    }
}
